--// ReplicatedStorage.SharedPackages._Index.roblox_roact@1.4.4.roact.SingleEventManager.spec (ModuleScript)

return function()
    local v_u_1 = require(script.Parent.assertDeepEqual)
    local v_u_2 = require(script.Parent.createSpy)
    local v_u_3 = require(script.Parent.Logging)
    local v_u_4 = require(script.Parent.SingleEventManager)
    describe("new", function()
        it("should create a SingleEventManager", function()
            local v5 = v_u_4.new()
            expect(v5).to.be.ok()
        end)
    end)
    describe("connectEvent", function()
        it("should connect to events", function()
            local v6 = Instance.new("BindableEvent")
            local v7 = v_u_4.new(v6)
            local v8 = v_u_2()
            v7:connectEvent("Event", v8.value)
            v7:resume()
            v6:Fire("foo")
            expect(v8.callCount).to.equal(1)
            v8:assertCalledWith(v6, "foo")
            v6:Fire("bar")
            expect(v8.callCount).to.equal(2)
            v8:assertCalledWith(v6, "bar")
            v7:connectEvent("Event", nil)
            v6:Fire("baz")
            expect(v8.callCount).to.equal(2)
        end)
        it("should drop events until resumed initially", function()
            local v9 = Instance.new("BindableEvent")
            local v10 = v_u_4.new(v9)
            local v11 = v_u_2()
            v10:connectEvent("Event", v11.value)
            v9:Fire("foo")
            expect(v11.callCount).to.equal(0)
            v10:resume()
            v9:Fire("bar")
            expect(v11.callCount).to.equal(1)
            v11:assertCalledWith(v9, "bar")
        end)
        it("should invoke suspended events when resumed", function()
            local v12 = Instance.new("BindableEvent")
            local v13 = v_u_4.new(v12)
            local v14 = v_u_2()
            v13:connectEvent("Event", v14.value)
            v13:resume()
            v12:Fire("foo")
            expect(v14.callCount).to.equal(1)
            v14:assertCalledWith(v12, "foo")
            v13:suspend()
            v12:Fire("bar")
            expect(v14.callCount).to.equal(1)
            v13:resume()
            expect(v14.callCount).to.equal(2)
            v14:assertCalledWith(v12, "bar")
        end)
        it("should invoke events triggered during resumption in the correct order", function()
            local v_u_15 = Instance.new("BindableEvent")
            local v16 = v_u_4.new(v_u_15)
            local v_u_17 = {}
            local v20 = v_u_2(function(_, p18)
                local v19 = v_u_17
                table.insert(v19, p18)
                if p18 == 2 then
                    v_u_15:Fire(3)
                elseif p18 == 3 then
                    v_u_15:Fire(4)
                end
            end)
            v16:connectEvent("Event", v20.value)
            v16:suspend()
            v_u_15:Fire(1)
            v_u_15:Fire(2)
            v16:resume()
            expect(v20.callCount).to.equal(4)
            v_u_1(v_u_17, {
                1,
                2,
                3,
                4
            })
        end)
        it("should not invoke events fired during suspension but disconnected before resumption", function()
            local v21 = Instance.new("BindableEvent")
            local v22 = v_u_4.new(v21)
            local v23 = v_u_2()
            v22:connectEvent("Event", v23.value)
            v22:suspend()
            v21:Fire(1)
            v22:connectEvent("Event", nil)
            v22:resume()
            expect(v23.callCount).to.equal(0)
        end)
        it("should not yield events through the SingleEventManager when resuming", function()
            local v_u_24 = Instance.new("BindableEvent")
            local v_u_25 = v_u_4.new(v_u_24)
            v_u_25:connectEvent("Event", function()
                coroutine.yield()
            end)
            v_u_25:resume()
            local v26 = coroutine.create(function()
                v_u_24:Fire(5)
            end)
            local v27 = coroutine.resume
            assert(v27(v26))
            expect(coroutine.status(v26)).to.equal("dead")
            v_u_25:suspend()
            v_u_24:Fire(5)
            local v28 = coroutine.create(function()
                v_u_25:resume()
            end)
            local v29 = coroutine.resume
            assert(v29(v28))
            expect(coroutine.status(v28)).to.equal("dead")
        end)
        it("should not throw errors through SingleEventManager when resuming", function()
            local v30 = Instance.new("BindableEvent")
            local v_u_31 = v_u_4.new(v30)
            v_u_31:connectEvent("Event", function()
                error("Error from SingleEventManager test")
            end)
            v_u_31:resume()
            v_u_31:suspend()
            v30:Fire(5)
            local v32 = v_u_3.capture(function()
                v_u_31:resume()
            end)
            expect(#v32.errors).to.equal(0)
            expect(#v32.warnings).to.equal(1)
            expect(#v32.infos).to.equal(0)
            expect(v32.warnings[1]:find("Error from SingleEventManager test")).to.be.ok()
        end)
        it("should not overflow with events if manager:resume() is invoked when resuming a suspended event", function()
            local v_u_33 = Instance.new("BindableEvent")
            local v_u_34 = v_u_4.new(v_u_33)
            local v36 = v_u_2(function(_, p35)
                if p35 == 1 then
                    v_u_34:suspend()
                    v_u_33:Fire(2)
                    v_u_34:resume()
                end
            end)
            v_u_34:connectEvent("Event", v36.value)
            v_u_34:suspend()
            v_u_33:Fire(1)
            v_u_34:resume()
            expect(v36.callCount).to.equal(2)
        end)
    end)
    describe("connectPropertyChange", function()
        it("should connect to property changes", function()
            local v37 = Instance.new("Folder")
            local v38 = v_u_4.new(v37)
            local v39 = v_u_2()
            v38:connectPropertyChange("Name", v39.value)
            v38:resume()
            v37.Name = "foo"
            expect(v39.callCount).to.equal(1)
            v39:assertCalledWith(v37)
            v37.Name = "bar"
            expect(v39.callCount).to.equal(2)
            v39:assertCalledWith(v37)
            v38:connectPropertyChange("Name")
            v37.Name = "baz"
            expect(v39.callCount).to.equal(2)
        end)
        it("should throw an error if the property is invalid", function()
            local v40 = Instance.new("Folder")
            local v_u_41 = v_u_4.new(v40)
            expect(function()
                v_u_41:connectPropertyChange("foo", function() end)
            end).to.throw()
        end)
    end)
end